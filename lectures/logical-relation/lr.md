Intitial types club, 2021-05-06, Andreas Abel

Logical relations
=================

Origin:

- Gordon Plotkin ?
- Harvey Friedman, Equality between functionals (written 1970)

- Friedman: relate two models of simply-typed lambda-calculus (STLC)

- There are unary, binary, multi-ary logical relations.

Typed combinary logic
=====================

Types.

    a,b,c ::= o | a ⇒ b

Constants `k : aₖ`.

    K : b ⇒ a ⇒ b
    S : (a ⇒ b ⇒ c) ⇒ (a ⇒ b) ⇒ a ⇒ c

Terms are applicative, formed from constants.

    ------
    k : aₖ

    t : a ⇒ b
    u : a
    ---------
    t ∙ u : b

Base type(s).

    o ::= nat

    ze  : nat
    su  : nat ⇒ nat
    rec : a ⇒ (nat ⇒ a ⇒ a) ⇒ nat ⇒ a

Logical relation
----------------

Suppose two models `⦅_⦆` and `⟦_⟧` of combinatory logic, with their application functions

    ⦅∙⦆ : ⦅a ⇒ b⦆ → ⦅a⦆ → ⦅b⦆
    ⟦∙⟧ : ⟦a ⇒ b⟧ → ⟦a⟧ → ⟦b⟧

Then a logical relation

    _⟪a⟫_ : ⦅a⦆ → ⟦a⟧ → Prop

is usually defined by induction on type `a`:

    n  ⟪nat⟫  N  ⇔  ...    -- Put your property here
    f ⟪a ⇒ b⟫ F  ⇔  ∀ g ∈ ⦅a⦆, G ∈ ⟦a⟧.   g ⟪a⟫ G  →  f⦅.⦆g ⟪b⟫ F⟦∙⟧G

Variations exist, but this is the basic idea:
Lift the property from base type to compound types in a generic way.

Often one of the models is the identity (the syntax).

Fundamental theorem
-------------------

Theorem.  If `t : a` then `⦅t⦆ ⟪a⟫ ⟦t⟧`.

Proof by induction on `t : a`.

  - Case:  Application

        t : a ⇒ b
        u : a
        ---------
        t ∙ u : b

    This case follows by definition of `⟪a ⇒ b⟫` using the induction hypotheses.

  - Case: `K : b ⇒ a ⇒ b`.
    Show `⦅K⦆ ⟪b ⇒ a ⇒ b⟫ ⟦K⟧`.
    Assume `g ⟪b⟫ G` and `h ⟪a⟫ H` and show

        ⦅K⦆ ⦅∙⦆ g ⦅∙⦆ h  ⟪b⟫  ⟦K⟧ ⟦∙⟧ G ⟦∙⟧ H

    Follows by definition of `⦅K⦆ and ⟦K⟧`.

  - Other constants analogously.


Corollary.  If `t : o` then desired property holds.
Proof.  By the fundamental theorem, `⦅t⦆ ⟪o⟫ ⟦t⟧`, which implies the property.


Example: Canonicity for Gödel's T in combinatory logic form (CA-ℕ)
-----------------------------------------------------------

Let numerals be generated by the function

    ⌜_⌝ : ℕ → { t ∣ t : nat }
    ⌜0⌝   = ze
    ⌜n+1⌝ = su ∙ ⌜n⌝

We would like to show canonicity, that each `t : nat` reduces to a numeral.

The standard model of CA-ℕ is:

    ⟦nat⟧           = ℕ
    ⟦a ⇒ b⟧         = ⟦a⟧ → ⟦b⟧

    ⟦K⟧ f g         = f
    ⟦S⟧ f g x       = f x (g x)
    ⟦ze⟧            = 0
    ⟦su⟧ n          = n+1
    ⟦rec⟧ g f 0     = g
    ⟦rec⟧ g f (n+1) = f n (⟦rec⟧ g f n)

Theorem (canonicity).   If `t : nat` then `t ↦* ⌜⟦t⟧⌝`.

Logical relation.

    _⟪a⟫_ : Tm a → ⟦a⟧ → Prop

    t ⟪nat⟫ 0    ⇔  t ↦* ze
    t ⟪nat⟫ n+1  ⇔  t ↦* su ∙ t' and  t' ⟪nat⟫ n

    t ⟪a⇒b⟫ f    ⇔  ∀ u,g.  u ⟪a⟫ g  →  t∙u ⟪b⟫ f g

Lemma (escape).   If `t ⟪nat⟫ n` then  `t ↦* ⌜n⌝`.

So canonicity follows from the fundamental theorem.

Fundamental theorem.   If `t : a` then `t ⟪a⟫ ⟦t⟧`.
Proof by induction on `t : a`.

  - Case `K : b ⇒ a ⇒ b`.
    Assume `t ⟪b⟫ f` and `u ⟪a⟫ g` and show `K∙t∙u  ⟪b⟫  ⟦K⟧ f g`.
    Almost there: `K∙t∙u ↦ t ⟪b⟫ f = ⟦K⟧ f g`.
    We need closure of LHS under (weak head) expansion.

Lemma (expansion).   If `t ↦ t' ⟪a⟫ f` then `t ⟪a⟫ f`.
Proof by induction on `a`.



Simply-typed lambda calculus
============================

When going from CA to STLC, we have to handle contexts `Γ` (lists of types).

Terms.  `t : Tm Γ a` written `t : Γ ⊢ a` (or traditionally `Γ ⊢ t : a`).

        a ∈ Γ        Γ.a ⊢ b         Γ ⊢ a ⇒ b    Γ ⊢ a
    var -----    abs ---------   app -------------------
        Γ ⊢ a        Γ ⊢ a ⇒ b       Γ ⊢ b

                     Γ ⊢ nat         Γ ⊢ a    Γ.nat.a ⊢ a    Γ ⊢ nat
    ze -------   su  -------     rec -------------------------------
       Γ ⊢ nat       Γ ⊢ nat         Γ ⊢ a

The interpreters are now relying on an environment:

    ⦅_⦆ : Tm Γ a → ⦅Γ⦆ → ⦅a⦆
    ⟦_⟧ : Tm Γ a → ⟦Γ⟧ → ⟦a⟧

Lifting the logical relation to environments:  `γ ⟪Γ⟫ ρ`.

    ε ⟪ε⟫ ε

    γ ⟪Γ⟫ ρ    f ⟪a⟫ F
    -------------------
    γ.f  ⟪Γ.a⟫  ρ.F

Fundamental theorem:  If `t : Γ ⊢ a` and `γ ⟪Γ⟫ ρ`, then `⦅t⦆γ ⟪a⟫ ⟦t⟧ρ`.
Proof by induction on `t : Γ ⊢ a`.

  - Case: variable `x : a ∈ Γ`.
    `γ(x) ⟪Γ(x)⟫ ρ(x)` by definition of `γ ⟪Γ⟫ ρ`.

  - Case: application (unchanged, still trivial).

  - Case: abstraction

            t : Γ.a ⊢ b
        ------------------
        abs t : Γ ⊢ a ⇒ b

    Assume `g ⟪a⟫ G`, show

        ⦅abs t⦆γ ⦅∙⦆ g  ⟪b⟫  ⟦abs t⟧ρ ⟦∙⟧ G

    IH:

        ⦅t⦆(γ.g) ⟪b⟫  ⟦t⟧(ρ.G)

    Rest by requirement ("expansion") on the model:  `⦅abs t⦆γ ⦅∙⦆ g = ⦅t⦆(γ.g)`.

Exercises:

  1. Port the canonicity result for CA to STLC!

  2. Define a call-by-value interpreter for STLC
     (either by big-step operational semantics or a partial function)
     and prove that each closed term `t : ε ⊢ nat`
     evaluates to a numeral.


Kripke logical relations
========================

- Relate _presheaf_ models of STLC.

- Allows us to prove e.g. properties of open terms (base category: contexts).
  * Weak/strong normalization
  * NbE

- Base category could be `ℕ` (step-indexing), heaps (modelling separation logic)...

- At function types, define LR by the exponential in presheafs.


Example: Base category is a preorder (W,≤) of worlds.

    _⟪a⟫w_ : ⦅a⦆w → ⟦a⟧w → Prop

    f  ⟪  o  ⟫w  F   ⇔   some property monotone in w
    f  ⟪a ⇒ b⟫w  F   ⇔   ∀ w'≤w,  g ⟪a⟫w' G  →  f⦅∙⦆g  ⟪b⟫w'  F⟦∙⟧G

Lemma (monotonicity):   If  `f ⟪a⟫w F`  and `w' ≤ w` then `f ⟪a⟫w' F`.
By induction on `a`.

Lemma (monotonicity):   If  `γ ⟪Γ⟫w ρ`  and `w' ≤ w` then `γ ⟪a⟫w' ρ`.
By induction on `Γ`.

Fundamental theorem:    If `t : Γ ⊢ a` and `γ ⟪Γ⟫w ρ` then `⦅t⦆wγ ⟪a⟫w ⟦t⟧wγ`.
Proof by induction on `t : Γ ⊢ a`.

  - Case: application

        t : Γ ⊢ a ⇒ b    u : Γ ⊢ a
        ---------------------------
        app t u : Γ ⊢ b

    Show: `⦅app t u⦆wγ ⟪b⟫w ⟦app t u⟧wρ`.
    IH2: `⦅u⦆wγ ⟪a⟫w ⟦u⟧wρ`
    IH1: `⦅t⦆wγ ⟪a ⇒ b⟫w ⟦t⟧wρ`, so with `w≤w` have `⦅t⦆wγ ⦅∙⦆ ⦅u⦆wγ  ⟪b⟫w  ⟦t⟧wρ ⟦∙⟧ ⟦u⟧wρ`.

  - Case: abstraction.

            t : Γ.a ⊢ b
        -----------------
        abs t : Γ ⊢ a ⇒ b

    Show: `⦅abs t⦆wγ  ⟪a ⇒ b⟫w  ⟦abs t⟧wρ`.
    Assume `w' ≤ w` and `f ⟪a⟫w' F` and show `⦅abs t⦆wγ ⦅∙⦆ f  ⟪b⟫w'  ⟦abs t⟧wρ ⟦∙⟧ F`.
    By monotonicity, `γ ⟪Γ⟫w' ρ`.
    By induction hypothesis `⦅t⦆w'(γ.f) ⟪a⟫w' ⟦t⟧w'(ρ.F)`.
    The rest by expansion property in the model `⦅abs t⦆wγ ⦅∙⦆ f = ⦅t⦆w'(γ.f)`.

□
